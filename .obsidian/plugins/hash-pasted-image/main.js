/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HashPastedImagePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_path = __toESM(require("path"));

// src/settings.ts
var DEFAULT_SETTINGS = {
  hashAlgorithm: "sha512" /* SHA512 */,
  encodingDigest: "hex" /* HEX */,
  copyImageFileSupport: false,
  othersFileSupport: false,
  notification: true,
  hashContext: false
};

// src/utils.ts
var import_crypto = __toESM(require("crypto"));
var hash = (algorithm, digest, contents) => {
  const digenc = digest;
  return import_crypto.default.createHash(algorithm).update(contents).digest(digenc).replaceAll("=", "");
};
var stringToHashAlgorithm = (str) => {
  switch (str) {
    case "sha256":
      return "sha256" /* SHA256 */;
    case "sha384":
      return "sha384" /* SHA384 */;
    case "sha512":
      return "sha512" /* SHA512 */;
    case "md5":
      return "md5" /* MD5 */;
    default:
      return "sha512" /* SHA512 */;
  }
};
var stringToEncodeDigest = (str) => {
  switch (str) {
    case "hex":
      return "hex" /* HEX */;
    case "base64url":
      return "base64url" /* BASE64URL */;
    default:
      return "hex" /* HEX */;
  }
};
var arrayBufferEqual = (buf1, buf2) => {
  if (buf1.byteLength != buf2.byteLength) return false;
  let dv1 = new Uint8Array(buf1);
  let dv2 = new Uint8Array(buf2);
  for (let i = 0; i < buf1.byteLength; i++) {
    if (dv1[i] != dv2[i]) return false;
  }
  return true;
};
var delay = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// src/main.ts
var PASTED_IMAGE_PREFIX = "Pasted image ";
var TIME_GAP_MS = 5e3;
var TIME_DELAY = 200;
var HashPastedImagePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (!(file instanceof import_obsidian.TFile)) return;
        const timeGapMs = (/* @__PURE__ */ new Date()).getTime() - file.stat.ctime;
        if (timeGapMs > TIME_GAP_MS) return;
        if (isMarkdownFile(file)) return;
        const isFileSupport = this.settings.copyImageFileSupport && isSupportedFile(file, this.settings.othersFileSupport);
        const isPasted = isPastedImage(file);
        if (isFileSupport || isPasted) {
          await this.startRenameProcess(file);
        }
      })
    );
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async startRenameProcess(file) {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return;
    }
    const originName = file.name;
    const newName = await this.generateNewName(file);
    const newPath = import_path.default.join(file.parent.path, newName);
    const isRename = await this.fixHashCollision(file, originName, newPath);
    if (isRename) {
      try {
        await delay(TIME_DELAY);
        await this.app.fileManager.renameFile(file, newPath);
      } catch (err) {
        console.log(err);
        throw err;
      }
    }
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!editor) {
      return;
    }
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let replacedLine = line.replace(originName, newName);
    if (line == replacedLine) {
      replacedLine = line.replace(encodeURI(originName), newName);
    }
    editor.transaction({
      changes: [
        {
          from: { ...cursor, ch: 0 },
          to: { ...cursor, ch: line.length },
          text: replacedLine
        }
      ]
    });
    if (this.settings.notification) {
      new import_obsidian.Notice(`Pasted image renamed to ${newName}`);
    }
  }
  async generateNewName(file) {
    let hashContext;
    if (this.settings.hashContext) {
      const imageContent = await file.vault.readBinary(file);
      hashContext = new Uint8Array(imageContent);
    } else {
      hashContext = file.name + (/* @__PURE__ */ new Date()).toString();
    }
    const name = hash(
      this.settings.hashAlgorithm,
      this.settings.encodingDigest,
      hashContext
    );
    return name + "." + file.extension;
  }
  async fixHashCollision(file, originName, newPath) {
    let isRename = true;
    if (this.settings.hashContext) {
      const renamedFile = this.app.vault.getAbstractFileByPath(
        (0, import_obsidian.normalizePath)(newPath)
      );
      if (renamedFile instanceof import_obsidian.TFile) {
        const imageContent = await file.vault.readBinary(file);
        const renamedContext = await renamedFile.vault.readBinary(renamedFile);
        if (arrayBufferEqual(imageContent, renamedContext)) {
          isRename = false;
          await this.app.fileManager.trashFile(file);
          if (this.settings.notification) {
            try {
              new import_obsidian.Notice(
                `Pasted image ${originName} already exists hashed file, and has been removed.`
              );
            } catch (err) {
              console.error(err);
            }
          }
        }
      }
    }
    return isRename;
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...loadedData };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var isPastedImage = (file) => {
  if (file instanceof import_obsidian.TFile) {
    if (file.name.startsWith(PASTED_IMAGE_PREFIX)) {
      return true;
    }
  }
  return false;
};
var isSupportedFile = (file, othersFileSupport) => {
  if (file instanceof import_obsidian.TFile) {
    const imageValidExtensions = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "bmp",
      "tiff",
      "tif",
      "webp",
      "heif",
      "heic",
      "svg",
      "ico"
    ];
    const videoValidExtensions = [
      "mp4",
      "mkv",
      "webm",
      "avi",
      "mov",
      "flv",
      "wmv"
    ];
    const audioValidExtensions = ["mp3", "wav", "flac", "aac", "ogg", "m4a"];
    const documentValidExtensions = [
      "pdf",
      "doc",
      "docx",
      "xls",
      "xlsx",
      "ppt",
      "pptx",
      "txt"
    ];
    const validExtensions = [
      ...imageValidExtensions,
      ...othersFileSupport ? videoValidExtensions : [],
      ...othersFileSupport ? audioValidExtensions : [],
      ...othersFileSupport ? documentValidExtensions : []
    ];
    return validExtensions.includes(file.extension.toLowerCase());
  }
  return false;
};
var isMarkdownFile = (file) => {
  if (file instanceof import_obsidian.TFile) {
    if (file.extension === "md") {
      return true;
    }
  }
  return false;
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Hash Pasted Image Settings" });
    containerEl.createEl("p", {
      text: "Auto rename pasted images added to the vault via hash algorithm SHA-512"
    });
    new import_obsidian.Setting(containerEl).setName("Hash Algorithm").setDesc("Algorithm to hash the pasted image name.").addDropdown(
      (dropdown) => dropdown.addOption("sha256" /* SHA256 */, "SHA-256").addOption("sha384" /* SHA384 */, "SHA-384").addOption("sha512" /* SHA512 */, "SHA-512").addOption("md5" /* MD5 */, "MD5").setValue(this.plugin.settings.hashAlgorithm).onChange(async (value) => {
        this.plugin.settings.hashAlgorithm = stringToHashAlgorithm(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Encoding Digest").setDesc("Binary-to-text encoding.").addDropdown(
      (dropdown) => dropdown.addOption("hex" /* HEX */, "Hex").addOption("base64url" /* BASE64URL */, "Base64 URL").setValue(this.plugin.settings.encodingDigest).onChange(async (value) => {
        this.plugin.settings.encodingDigest = stringToEncodeDigest(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Copy Image File Support").setDesc(
      "Turn on to rename image files (not copy from clipboard) copied to the vault. Support formats: jpg, jpeg, png, gif, bmp, tiff, tif, webp, heif, heic, svg, ico."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.copyImageFileSupport).onChange(async (value) => {
        this.plugin.settings.copyImageFileSupport = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Others File Support").setDesc(
      "Turn on to rename other files (video, audio, document) copied to the vault. See supported formats in the code."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.othersFileSupport).onChange(async (value) => {
        this.plugin.settings.othersFileSupport = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Notification").setDesc("Show a notification when a pasted image is renamed.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.notification).onChange(async (value) => {
        this.plugin.settings.notification = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("HashContext").setDesc("Gen hash by filename or file context").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.hashContext).onChange(async (value) => {
        this.plugin.settings.hashContext = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */